// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSMain2
#pragma kernel CSMain3
#pragma kernel CSMain4

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct data
{
    float3 A;
    float3 B;
    int indexA;
    int indexB;
};

RWStructuredBuffer<data> edges;

RWStructuredBuffer<int> indexA;
RWStructuredBuffer<int> indexB;

RWStructuredBuffer<int> foundOne;
//RWStructuredBuffer<int> indexFound;

//RWStructuredBuffer<float3> positionACheck;

//RWStructuredBuffer<float3> positionBCheck;

AppendStructuredBuffer<int> result;





[numthreads(15, 15,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if ((indexA[id.x] == indexA[id.y] &&
        indexB[id.x] == indexB[id.y]) ||
        (indexA[id.x] == indexB[id.y] &&
        indexB[id.x] == indexA[id.y]))
    {
        if (id.x != id.y)
        {
            result.Append(id.x);
        }
    }
}


[numthreads(15, 15, 1)]
void CSMain2(uint3 id : SV_DispatchThreadID)
{
    
    if ((indexA[id.x] == indexA[id.y] &&
        indexB[id.x] == indexB[id.y]) ||
        (indexA[id.x] == indexB[id.y] &&
        indexB[id.x] == indexA[id.y]))
    {
        if (id.x != id.y)
        {
            foundOne[id.x] = 1;

        }
    }
   
    if (id.y == 134700 && foundOne[id.x] == 0)
    {
        result.Append(id.x);
    }
}


RWStructuredBuffer<float3> positionA;
RWStructuredBuffer<float3> positionB;

int count;
float Epsilon;

//get outer edge
[numthreads(30, 30, 1)]
void CSMain3(uint3 id : SV_DispatchThreadID)
{
    //checks the 2 positions on epsilon
    if ((distance(positionA[id.x], positionA[id.y]) <= Epsilon
        &&
        distance(positionB[id.x], positionB[id.y]) <= Epsilon)
        ||
        (distance(positionA[id.x], positionB[id.y]) <= Epsilon
        &&
        distance(positionB[id.x], positionA[id.y]) <= Epsilon))
    {
        if (id.x != id.y)
        {
            foundOne[id.x] = 1;
        }
    }

    //if (id.y == count && foundOne[id.x] == 0)
    //{
    //    result.Append(id.x);
    //}
}

int startpoint;

[numthreads(11, 92, 1)]
void CSMain4(uint3 id : SV_DispatchThreadID)
{
    //checks the 2 positions on epsilon
    if ((distance(positionA[startpoint + id.x], positionA[id.y]) <= Epsilon
        &&
        distance(positionB[startpoint + id.x], positionB[id.y]) <= Epsilon)
        ||
        (distance(positionA[startpoint + id.x], positionB[id.y]) <= Epsilon
        &&
        distance(positionB[startpoint + id.x], positionA[id.y]) <= Epsilon))
    {
        if (startpoint + id.x != id.y)
        {
            foundOne[startpoint + id.x] = 1;
        }
    }

    //if (id.y == count && foundOne[id.x] == 0)
    //{
    //    result.Append(id.x);
    //}
}

//bool check(float3 v1, float3 v2)
//{
//    //return abs(distance(v1, v2) <= epsilon);
    
//    if (distance(v1, v2) <= epsilon)
//    {
//        return true;
//    }
//}